# .github/workflows/ci.yml
name: CI

# Start the build with a push to any branch and with a pull request in the main
on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]

jobs:
  build:
    # Choosing different operating systems for testing
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        # Defining the Qt architecture for each OS
        include:
          - os: ubuntu-latest
            qt_arch: 'linux_gcc_64'        # For Linux
          - os: windows-latest
            qt_arch: 'win64_mingw'   # For Windows (suitable for MinGW/LLVM-MinGW)
          - os: macos-latest
            qt_arch: 'clang_64'      # For macOS

    runs-on: ${{ matrix.os }}

    steps:
    # 1. Clone the repository
    - name: Checkout repository
      uses: actions/checkout@v4

    # 2. Installing Qt
    # Uses the official action to install Qt
    - name: Install Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: '6.10.2' # target Qt version
        host: ${{ matrix.os == 'ubuntu-latest' && 'linux' || matrix.os == 'windows-latest' && 'windows' || 'mac' }}
        target: 'desktop'
        arch: ${{ matrix.qt_arch }}
        # For Windows: arch: 'win64_msvc2019_64' or 'win64_mingw' (depending on your build)
        # If you are using MinGW on Windows, change the arch below
        modules: '' # Add modules if necessary, for example: 'qtcharts qtnetworkauth'
        tools: ''

    # 3. Installing CMake and Ninja (if not installed)
    - name: Install CMake and Ninja (Ubuntu)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake ninja-build

    - name: Install CMake and Ninja (macOS)
      if: runner.os == 'macOS'
      run: |
        brew install cmake ninja

    # For Windows, CMake and Ninja may already be installed with Qt, but you can make sure
    # AND we need to ensure the MinGW path is correctly added to PATH
    - name: Install CMake and Ninja (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System'
        choco install ninja

    # NEW: Debug step - list the Qt directory structure to find the real MinGW folder name
    - name: Debug / Find Qt install path (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "QT_BASE_PATH = $env:QT_BASE_PATH"
        Write-Host "QT_ROOT_DIR = $env:QT_ROOT_DIR"
        Write-Host "Checking contents of QT_BASE_PATH:"
        Get-ChildItem "$env:QT_BASE_PATH"
        Write-Host "Checking for MinGW folders in QT_BASE_PATH:"
        $folders = Get-ChildItem "$env:QT_BASE_PATH" | Where-Object { $_.Name -like "*mingw*" }
        foreach ($folder in $folders) {
            Write-Host "Found MinGW folder: $($folder.Name)"
            Write-Host "Contents of $($folder.FullName)\bin:"
            Get-ChildItem "$($folder.FullName)\bin" | Where-Object { $_.Name -like "*g++.exe" } | Select-Object Name
        }

    # 4. Build example
    - name: Build Example App (Linux/macOS)
      if: runner.os != 'Windows'
      run: |
        cd example
        mkdir build
        cd build
        cmake .. -G "Ninja" -DCMAKE_BUILD_TYPE=Release
        cmake --build .

    - name: Build Example App (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        cd example
        mkdir build
        cd build

        # QT_BASE_PATH is already the path to the MinGW bin directory (e.g., .../mingw_64)
        $qtBin = "$env:QT_BASE_PATH"
        Write-Host "Using Qt binaries from: $qtBin"

        # Check for the compiler in $qtBin directly
        $gppFile = Get-ChildItem "$qtBin" | Where-Object { $_.Name -like "x86_64-w64-mingw32-g++.exe" } | Select-Object -First 1
        if (-Not $gppFile) {
            Write-Error "Compiler x86_64-w64-mingw32-g++.exe not found in $qtBin"
            Write-Host "Available files:"
            Get-ChildItem "$qtBin" | Where-Object { $_.Name -like "*g++*" } | Select-Object Name
            exit 1
        }

        $gppPath = $gppFile.FullName
        $gccPath = $gppPath.Replace("g++.exe", "gcc.exe")

        Write-Host "Found C++ compiler: $gppPath"
        Write-Host "Found C compiler: $gccPath"

        # Set environment variables
        $env:CXX = $gppPath
        $env:CC = $gccPath
        $env:PATH = "$qtBin;$env:PATH"

        # Run CMake
        cmake .. -G "Ninja" -DCMAKE_BUILD_TYPE=Release `
                 -DCMAKE_C_COMPILER="$gccPath" `
                 -DCMAKE_CXX_COMPILER="$gppPath" `
                 -DCMAKE_MAKE_PROGRAM=ninja

        if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

        cmake --build .
        if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
        
        Write-Host "âœ… Build successful!"

    # (Optional) Running the example (only if it is headless)
    # - name: Run Example App (Linux/macOS)
    #   if: runner.os != 'Windows'
    #   run: |
    #     cd example/build
    #     ./ExampleApp # # or whatever the executable file is called.

    # - name: Run Example App (Windows)
    #   if: runner.os == 'Windows'
    #   shell: pwsh
    #   run: |
    #     cd example/build
    #     .\ExampleApp.exe # or whatever the executable file is called.
